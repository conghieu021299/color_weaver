<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flow Puzzle – Color Weaver (Enhanced UI)</title>
    <script>
        tailwind.config = {
          darkMode: 'class' // chỉ kích hoạt dark khi <html class="dark">
        }
      </script>
    <!-- Tailwind CDN (dev only) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html, body { height: 100%; }
      .touch-none { touch-action: none; }

      /* Card glass & board elevation */
      .glass {
        background: rgba(255,255,255,0.7);
        backdrop-filter: blur(8px);
      }
      .board-shadow {
        box-shadow:
          0 20px 40px rgba(0,0,0,0.12),
          inset 0 1px 0 rgba(255,255,255,0.6);
      }

      /* Color glow ring for endpoints & fills */
      .glow-red    { box-shadow: 0 0 0 3px rgba(239,68,68,0.25); }
      .glow-blue   { box-shadow: 0 0 0 3px rgba(59,130,246,0.25); }
      .glow-yellow { box-shadow: 0 0 0 3px rgba(250,204,21,0.3); }
      .glow-green  { box-shadow: 0 0 0 3px rgba(34,197,94,0.25); }
      .glow-orange { box-shadow: 0 0 0 3px rgba(249,115,22,0.25); }
      .glow-purple { box-shadow: 0 0 0 3px rgba(168,85,247,0.25); }
      .glow-teal   { box-shadow: 0 0 0 3px rgba(20,184,166,0.25); }
      .glow-pink   { box-shadow: 0 0 0 3px rgba(236,72,153,0.25); }

      /* Completed overlay animation */
      @keyframes pop {
        0% { transform: scale(0.9); opacity: 0; }
        60% { transform: scale(1.03); opacity: 1; }
        100% { transform: scale(1); }
      }
      .pop-anim { animation: pop .35s ease-out both; }

      /* Subtle animated gradient background */
      .bg-animated {
        background: radial-gradient(1200px 800px at 10% 10%, #fafafa, #f1f5f9 50%, #e2e8f0 100%);
      }
      @media (prefers-color-scheme: dark) {
        .bg-animated {
          background: radial-gradient(1200px 800px at 10% 10%, #0b1220, #0f172a 50%, #0b1020 100%);
        }
      }
    </style>
  </head>

  <body class="bg-animated text-black">
    <div id="root"></div>

    <!-- React 18 + ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel standalone để biên dịch JSX trong trình duyệt (dev only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- App chính (ES module). Chỉ dùng preset 'react' -->
    <script type="text/babel" data-presets="react" data-type="module">
      import LEVELS from './levels.js';
      const { useEffect, useMemo, useRef, useState } = React;

      // ---------------- Helpers ----------------
      const key = (x, y) => `${x},${y}`;

      const dirs = [
        { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      ];
      const isAdj = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1;

      const COLOR_FILL = {
        red: "bg-red-500", blue: "bg-blue-500", yellow: "bg-yellow-400",
        green: "bg-green-500", orange: "bg-orange-500", purple: "bg-purple-500",
        teal: "bg-teal-500", pink: "bg-pink-500",
      };
      const COLOR_BORDER = {
        red: "border-red-400", blue: "border-blue-400", yellow: "border-yellow-300",
        green: "border-green-400", orange: "border-orange-400", purple: "border-purple-400",
        teal: "border-teal-400", pink: "border-pink-400",
      };
      const COLOR_GLOW = {
        red: "glow-red", blue: "glow-blue", yellow: "glow-yellow",
        green: "glow-green", orange: "glow-orange", purple: "glow-purple",
        teal: "glow-teal", pink: "glow-pink",
      };

      // ---------------- Component ----------------
      // Trả về hàng xóm hợp lệ (kể cả portal)
function neighborsOf(N, x, y, portalMap) {
  const out = [
    {x:x+1,y}, {x:x-1,y}, {x, y:y+1}, {x, y:y-1},
  ].filter(p => p.x>=0 && p.y>=0 && p.x<N && p.y<N);
  const k = `${x},${y}`;
  const portal = portalMap.get(k);
  if (portal) out.push({ x: portal.x, y: portal.y, viaPortal: true });
  return out;
}

// Áp dụng logic mix giống gameplay
function mixAfter(cell, color, mixNodes, MIX_RULES) {
  const mn = mixNodes.get(`${cell.x},${cell.y}`);
  if (!mn) return color;
  return MIX_RULES[`${color}+${mn.pigment}`] || color;
}

      function FlowPuzzle() {
        const [levelIndex, setLevelIndex] = useState(0);
        const level = LEVELS[levelIndex];
        const N = level.gridSize;

        const nodesByCell = useMemo(() => {
          const map = new Map();
          for (const n of level.nodes) map.set(key(n.x, n.y), { color: n.color });
          return map;
        }, [level]);

        const endpointsByColor = useMemo(() => {
          const by = {};
          for (const n of level.nodes) {
            by[n.color] = by[n.color] || [];
            by[n.color].push({ x: n.x, y: n.y });
          }
          return by;
        }, [level]);

        const obstacles = useMemo(
          () => new Set((level.obstacles || []).map(o => key(o.x, o.y))),
          [level]
        );
        const bridges = useMemo(
          () => new Set((level.bridges || []).map(o => key(o.x, o.y))),
          [level]
        );
        const portalMap = useMemo(() => {
          const m = new Map();
          for (const p of (level.portals || [])) {
            m.set(key(p.a.x, p.a.y), { x: p.b.x, y: p.b.y });
            m.set(key(p.b.x, p.b.y), { x: p.a.x, y: p.a.y });
          }
          return m;
        }, [level]);
        const mixNodes = useMemo(() => {
          const m = new Map();
          for (const mn of (level.mixNodes || []))
            m.set(key(mn.x, mn.y), { pigment: mn.pigment });
          return m;
        }, [level]);

        const MIX_RULES = useMemo(() => ({
          "red+blue": "purple", "blue+red": "purple",
          "red+yellow": "orange","yellow+red": "orange",
          "blue+yellow":"green","yellow+blue":"green",
        }), []);

        const [occupancy, setOccupancy] = useState(
          Array.from({ length: N }, () => Array.from({ length: N }, () => null))
        );
        const [bridgeOcc, setBridgeOcc] = useState({});
        const [paths, setPaths] = useState({});
        const [active, setActive] = useState(null);
        const [showGrid, setShowGrid] = useState(true); // toggle grid lines (UI only)
        const boardRef = useRef(null);

        // Undo history
        const [history, setHistory] = useState([]);
        function takeSnapshot() {
          setHistory(h => [
            ...h,
            {
              occupancy: occupancy.map(r => r.slice()),
              bridgeOcc: Object.fromEntries(
                Object.entries(bridgeOcc).map(([k, v]) => [k, Array.from(v || [])])
              ),
              paths: Object.fromEntries(
                Object.entries(paths).map(([c, p]) => [c, p.map(pp => ({ ...pp }))])
              ),
              active: active ? { color: active.color, path: active.path.map(p => ({ ...p })) } : null,
            },
          ]);
        }
        function undo() {
          const prev = history[history.length - 1];
          if (!prev) return;
          setHistory(h => h.slice(0, -1));
          setOccupancy(prev.occupancy.map(r => r.slice()));
          setBridgeOcc(
            Object.fromEntries(Object.entries(prev.bridgeOcc).map(([k, arr]) => [k, new Set(arr)]))
          );
          setPaths(
            Object.fromEntries(Object.entries(prev.paths).map(([c, p]) => [c, p.map(pp => ({ ...pp }))]))
          );
          setActive(prev.active ? { color: prev.active.color, path: prev.active.path.map(p => ({ ...p })) } : null);
        }

        // Reset khi đổi level
        useEffect(() => {
          setPaths({});
          setActive(null);
          setOccupancy(Array.from({ length: N }, () => Array.from({ length: N }, () => null)));
          setBridgeOcc({});
          setHistory([]);
        }, [N, levelIndex]);

        // Tính cell theo toạ độ con trỏ
        function pointToCell(clientX, clientY) {
          const el = boardRef.current;
          if (!el) return null;
          const rect = el.getBoundingClientRect();
          const size = Math.min(rect.width, rect.height);
          const cell = size / N;
          const offsetX = clientX - rect.left;
          const offsetY = clientY - rect.top;
          const startX = (rect.width - size) / 2;
          const startY = (rect.height - size) / 2;
          const xIn = offsetX - startX;
          const yIn = offsetY - startY;
          if (xIn < 0 || yIn < 0 || xIn >= size || yIn >= size) return null;
          const x = Math.floor(xIn / cell);
          const y = Math.floor(yIn / cell);
          if (x < 0 || y < 0 || x >= N || y >= N) return null;
          return { x, y };
        }

        function eraseColor(prev, color) {
          const clone = prev.map(row => row.slice());
          for (let y = 0; y < N; y++)
            for (let x = 0; x < N; x++)
              if (clone[y][x] === color) clone[y][x] = null;
          return clone;
        }

        function occupyBridgeCell(kc, color) {
          setBridgeOcc(prev => {
            const next = { ...prev };
            const s = new Set(Array.from((prev[kc] || [])));
            s.add(color);
            next[kc] = s;
            return next;
          });
        }

        // === Core logic giữ nguyên ===
        function startDrawAt(cell) {
          const node = nodesByCell.get(key(cell.x, cell.y));
          if (!node) return; // must start at a node
          takeSnapshot();
          const color = node.color;

          setPaths(prev => {
            const np = { ...prev };
            if (np[color]) delete np[color];
            return np;
          });

          setOccupancy(prev => eraseColor(prev, color));

          setBridgeOcc(prev => {
            const copy = {};
            for (const [k, v] of Object.entries(prev)) {
              const nv = new Set(Array.from(v || []));
              nv.delete(color);
              copy[k] = nv;
            }
            return copy;
          });

          const kStart = key(cell.x, cell.y);
          if (bridges.has(kStart)) {
            occupyBridgeCell(kStart, color);
          } else {
            setOccupancy(prev => {
              const next = prev.map(r => r.slice());
              next[cell.y][cell.x] = color;
              return next;
            });
          }

          setActive({ color, path: [cell] });
        }

        function handleMixIfAny(cell, color) {
          const mn = mixNodes.get(key(cell.x, cell.y));
          if (!mn) return color;
          const mixed = MIX_RULES[`${color}+${mn.pigment}`];

          return mixed || color;
        }

        function handleMoveTo(cell) {
          if (!active) return;
          const baseColor = active.color;
          const path = active.path;
          const last = path[path.length - 1];
          if (!isAdj(last, cell)) return;
          const k = key(cell.x, cell.y);
          if (obstacles.has(k)) return;

          let color = baseColor;

          if (path.length >= 2) {
            const prevCell = path[path.length - 2];
            if (cell.x === prevCell.x && cell.y === prevCell.y) {
              takeSnapshot();
              const newPath = path.slice(0, -1);
              setActive({ color, path: newPath });
              setOccupancy(prev => {
                const clone = prev.map(r => r.slice());
                clone[last.y][last.x] = null;
                return clone;
              });
              return;
            }
          }

          takeSnapshot();

          setOccupancy(prev => {
            let next = prev.map(r => r.slice());
            const occ = next[cell.y][cell.x];
            if (occ && occ !== color && !bridges.has(k)) {
              next = eraseColor(next, occ);
              setPaths(p => {
                const np = { ...p };
                delete np[occ];
                return np;
              });
            }
            if (bridges.has(k)) occupyBridgeCell(k, color);
            else next[cell.y][cell.x] = color;
            return next;
          });

          color = handleMixIfAny(cell, color);

          const newPath = [...path, cell];
          const endpoints = endpointsByColor[color] || endpointsByColor[baseColor];
          const reachedOther =
            endpoints &&
            endpoints.some(e => e.x === cell.x && e.y === cell.y) &&
            !(path.length === 1 && cell.x === path[0].x && cell.y === path[0].y);

          const portalDest = portalMap.get(k);
          let finalPath = newPath;
          if (portalDest) {
            finalPath = [...newPath, { x: portalDest.x, y: portalDest.y }];
            setOccupancy(prev => {
              const next = prev.map(r => r.slice());
              const kd = key(portalDest.x, portalDest.y);
              if (!bridges.has(kd)) next[portalDest.y][portalDest.x] = color;
              else occupyBridgeCell(kd, color);
              return next;
            });
          }

          if (reachedOther) {
            setPaths(prev => ({ ...prev, [color]: finalPath }));
            setActive(null);
          } else {
            setActive({ color, path: finalPath });
            setPaths(prev => ({ ...prev, [color]: finalPath }));
          }
        }

        function endDraw() {
          if (!active) return;
          const { color, path } = active;
          setPaths(prev => ({ ...prev, [color]: path }));
          setActive(null);
        }

        function isComplete() {
          for (const color of Object.keys(endpointsByColor)) {
            const p = paths[color];
            if (!p || p.length < 2) return false;
            const ends = endpointsByColor[color];
            const startOk = p.some(c => c.x === ends[0].x && c.y === ends[0].y);
            const endOk   = p.some(c => c.x === ends[1].x && c.y === ends[1].y);
            if (!startOk || !endOk) return false;
          }
          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = key(x, y);
              if (obstacles.has(k)) continue;
              const occ = occupancy[y][x];
              const b = bridgeOcc[k];
              if (!occ && !(b && b.size > 0)) return false;
            }
          }
          return true;
        }

        // % tiến độ (UI)
        function progressPercent() {
          let fillable = 0, filled = 0;
          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = key(x,y);
              if (obstacles.has(k)) continue;
              fillable++;
              const occ = occupancy[y][x];
              const b = bridgeOcc[k];
              if (occ || (b && b.size > 0)) filled++;
            }
          }
          return fillable ? Math.round((filled / fillable) * 100) : 0;
        }

        // BFS hint (giữ nguyên)
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        function bfsNextStepForColor(color) {
          const ends = endpointsByColor[color] || [];
          const s = ends[0], t = ends[1];
          if (!s || !t) return null;

          const passable = (x, y) => {
            const k = key(x, y);
            if (x < 0 || y < 0 || x >= N || y >= N) return false;
            if (obstacles.has(k)) return false;
            const occ = occupancy[y][x];
            if (bridges.has(k)) return true;
            return !occ || occ === color;
          };

          const q = [s];
          const prev = new Map();
          const seen = new Set([key(s.x, s.y)]);

          while (q.length) {
            const cur = q.shift();
            if (cur.x === t.x && cur.y === t.y) break;
            for (const d of dirs) {
              const nx = cur.x + d.dx;
              const ny = cur.y + d.dy;
              if (!passable(nx, ny)) continue;
              const kk = key(nx, ny);
              if (seen.has(kk)) continue;
              seen.add(kk);
              prev.set(kk, key(cur.x, cur.y));
              q.push({ x: nx, y: ny });
            }
          }

          const targetK = key(t.x, t.y);
          if (!prev.has(targetK)) return null;
          const path = [];
          let curK = targetK;
          while (curK) {
            const [xs, ys] = curK.split(",").map(Number);
            path.push({ x: xs, y: ys });
            curK = prev.get(curK);
          }
          path.reverse();
          return path.length >= 2 ? path[1] : null;
        }
// Tìm đường cho 1 màu từ 1 endpoint sang endpoint còn lại, có xét portal/bridge/mix
function solvePathForColor({
  color,
  N,
  occupancy,
  obstacles,
  bridges,
  portalMap,
  mixNodes,
  MIX_RULES,
  endpointsByColor,
}) {
  const ends = endpointsByColor[color];
  if (!ends || ends.length < 2) return null;

  const start = ends[0], goal = ends[1];

  const passable = (x, y, curColor) => {
    const k = `${x},${y}`;
    if (x<0 || y<0 || x>=N || y>=N) return false;
    if (obstacles.has(k)) return false;
    if (bridges.has(k)) return true; // bridge cho phép chồng lane
    const occ = occupancy[y][x];
    return !occ || occ === curColor;
  };

  const keyState = (x, y, curColor) => `${x},${y},${curColor}`;
  const stack = [{ x: start.x, y: start.y, path: [{x:start.x,y:start.y}], curColor: color }];
  const seen = new Set([keyState(start.x, start.y, color)]);

  while (stack.length) {
    const cur = stack.pop();
    // Thành công nếu chạm endpoint có màu trùng "curColor" hoặc màu gốc 'color'
    const goalList = endpointsByColor[cur.curColor] || endpointsByColor[color] || [];
    const reached = goalList.some(e => e.x === cur.x && e.y === cur.y) &&
                    !(cur.x === start.x && cur.y === start.y);
    if (reached) return cur.path;

    const ns = neighborsOf(N, cur.x, cur.y, portalMap);
    // heuristic: đi gần goal hơn trước
    ns.sort((a,b)=>{
      const ga = Math.min(...goalList.map(g => Math.abs(g.x-a.x)+Math.abs(g.y-a.y)));
      const gb = Math.min(...goalList.map(g => Math.abs(g.x-b.x)+Math.abs(g.y-b.y)));
      return gb - ga; // dùng stack (DFS), nên sort ngược để push “tốt” sau cùng
    });

    for (const nb of ns) {
      if (!passable(nb.x, nb.y, cur.curColor)) continue;

      // chạm mix → đổi màu
      const nextColor = mixAfter(nb, cur.curColor, mixNodes, MIX_RULES);
      const kst = keyState(nb.x, nb.y, nextColor);
      if (seen.has(kst)) continue;
      seen.add(kst);

      const nextPath = [...cur.path, {x:nb.x, y:nb.y}];
      stack.push({ x: nb.x, y: nb.y, path: nextPath, curColor: nextColor });
    }
  }
  return null;
}

// Sắp xếp thứ tự vẽ các màu (giảm xung đột): ưu tiên đường ngắn trước
function orderColors(endpointsByColor) {
  const list = Object.entries(endpointsByColor).map(([c, [a,b]]) => ({
    color: c, dist: Math.abs(a.x-b.x)+Math.abs(a.y-b.y)
  }));
  return list.sort((a,b)=>a.dist-b.dist).map(i=>i.color);
}

// Thực thi 1 lời giải: set paths + occupancy theo path
function applySolutionPaths(pathsMap, {N, bridges}) {
  const occ = Array.from({length:N},()=>Array.from({length:N},()=>null));
  const bOcc = {};
  for (const [c, path] of Object.entries(pathsMap)) {
    for (const cell of path) {
      const k = `${cell.x},${cell.y}`;
      if (bridges.has(k)) {
        bOcc[k] ??= new Set();
        bOcc[k].add(c);
      } else {
        occ[cell.y][cell.x] = c;
      }
    }
  }
  return { occ, bOcc };
}

// Tự giải: 'all' = toàn level, 'pair' = chỉ 1 màu còn thiếu
function autoSolve({ mode = 'all' } = {}) {
  // snapshot current
  const state = {
    N,
    obstacles,
    bridges,
    portalMap,
    mixNodes,
    MIX_RULES,
    endpointsByColor,
  };

  // clone occupancy để solver tham chiếu
  const occ = occupancy.map(r=>r.slice());
  const solution = {};
  const colors = mode === 'pair'
    ? Object.keys(endpointsByColor).filter(c => !paths[c] || paths[c].length < 2).slice(0,1)
    : orderColors(endpointsByColor);

  for (const c of colors) {
    // nếu đã có đường hợp lệ thì dùng luôn
    const cur = paths[c];
    let found = null;
    if (cur && cur.length >= 2) {
      found = cur;
    } else {
      found = solvePathForColor({
        color: c,
        N: state.N,
        occupancy: occ,
        obstacles: state.obstacles,
        bridges: state.bridges,
        portalMap: state.portalMap,
        mixNodes: state.mixNodes,
        MIX_RULES: state.MIX_RULES,
        endpointsByColor: state.endpointsByColor,
      });
    }

    if (!found) {
      // Nếu fail ở chế độ 'pair' → bỏ qua
      if (mode === 'pair') continue;
      // Ở 'all' thì dừng – không có lời giải
      return false;
    }
    solution[c] = found;

    // ghi tạm vào occ để các màu sau né đường đã đặt
    for (const cell of found) {
      const k = `${cell.x},${cell.y}`;
      if (bridges.has(k)) continue;
      occ[cell.y][cell.x] = c;
    }
  }

  // Áp dụng vào UI
  const { occ: newOcc, bOcc: newB } = applySolutionPaths(solution, {N, bridges});
  setPaths(solution);
  setActive(null);
  setOccupancy(newOcc);
  setBridgeOcc(newB);
  return true;
}

        function giveHint() {
  // mode: 'all' = giải trọn level; 'pair' = chỉ gợi ý 1 cặp còn thiếu
  takeSnapshot();
  const ok = autoSolve({ mode: 'all' });
  // nếu không giải trọn được (hiếm), fallback giải 1 cặp
  if (!ok) autoSolve({ mode: 'pair' });
}


        // Controls
        function resetLevel() {
          setPaths({});
          setActive(null);
          setOccupancy(Array.from({ length: N }, () => Array.from({ length: N }, () => null)));
          setBridgeOcc({});
          setHistory([]);
        }
        const nextLevel = () => setLevelIndex(i => Math.min(LEVELS.length - 1, i + 1));
        const prevLevel = () => setLevelIndex(i => Math.max(0, i - 1));

        // Events
        const complete = isComplete();
        const onPointerDown = e => { const c = pointToCell(e.clientX, e.clientY); if (c) startDrawAt(c); };
        const onPointerMove = e => { if (!active) return; const c = pointToCell(e.clientX, e.clientY); if (c) handleMoveTo(c); };
        const onPointerUp   = () => endDraw();

        const onTouchStart = e => { const t = e.touches[0]; if (!t) return; const c = pointToCell(t.clientX, t.clientY); if (c) startDrawAt(c); };
        const onTouchMove  = e => { const t = e.touches[0]; if (!t || !active) return; const c = pointToCell(t.clientX, t.clientY); if (c) handleMoveTo(c); };
        const onTouchEnd   = () => endDraw();

        // ---------- UI ----------
        const pct = progressPercent();

        return (
          <div className="min-h-screen w-full flex flex-col items-center gap-5 p-4 md:p-6">
            {/* Top bar */}
            <header className="w-full max-w-5xl glass rounded-2xl px-4 py-3 md:px-6 md:py-4 shadow-sm border border-white/50 dark:border-white/10">
              <div className="flex items-center justify-between gap-3">
                <div className="flex items-center gap-3">
                  <div className="w-9 h-9 rounded-xl bg-gradient-to-br from-indigo-500 to-purple-500 shadow ring-2 ring-white/50"></div>
                  <div>
                    <div className="text-xl md:text-2xl font-bold tracking-tight">Color Weaver</div>
                    <div className="text-xs md:text-sm text-gray-600 dark:text-slate-300/80">Connect the colors. Restore the world.</div>
                  </div>
                </div>

                <div className="hidden md:flex items-center gap-2">
                  <button onClick={prevLevel} className="px-3 py-2 rounded-xl bg-white/80 hover:bg-white shadow border text-sm">◀</button>
                  <div className="px-3 py-2 rounded-xl bg-white/80 shadow border text-sm font-semibold">{level.name}</div>
                  <button onClick={nextLevel} className="px-3 py-2 rounded-xl bg-white/80 hover:bg-white shadow border text-sm">▶</button>
                </div>

                <div className="flex items-center gap-2">
                  <button onClick={resetLevel} className="px-3 py-2 rounded-xl bg-white/80 hover:bg-white shadow border text-sm">Reset</button>
                  <button onClick={undo} className="px-3 py-2 rounded-xl bg-white/90 hover:bg-white shadow border text-sm">Undo</button>
                  <button onClick={giveHint} className="px-3 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700 shadow text-sm">Hint</button>
                </div>
              </div>

              {/* Level picker for mobile */}
              <div className="mt-3 flex md:hidden items-center justify-center gap-2">
                <button onClick={prevLevel} className="px-3 py-2 rounded-xl bg-white/80 hover:bg-white shadow border text-sm">◀</button>
                <div className="px-3 py-2 rounded-xl bg-white/80 shadow border text-sm font-semibold">{level.name}</div>
                <button onClick={nextLevel} className="px-3 py-2 rounded-xl bg-white/80 hover:bg-white shadow border text-sm">▶</button>
              </div>

              {/* Progress */}
              <div className="mt-3">
                <div className="flex items-center justify-between text-xs text-gray-600 dark:text-slate-300/80 mb-1">
                  <span>Tiến độ</span><span>{pct}%</span>
                </div>
                <div className="h-2 w-full rounded-full bg-gray-200 dark:bg-white/10 overflow-hidden">
                  <div className="h-full bg-gradient-to-r from-emerald-500 to-teal-500 transition-all" style={{width: pct + '%'}}></div>
                </div>
              </div>
            </header>

            {/* Board container */}
            <div
              ref={boardRef}
              className="relative w-full max-w-5xl aspect-square select-none touch-none glass rounded-3xl p-3 md:p-4 board-shadow"
              onPointerDown={onPointerDown}
              onPointerMove={onPointerMove}
              onPointerUp={onPointerUp}
              onPointerCancel={onPointerUp}
              onTouchStart={onTouchStart}
              onTouchMove={onTouchMove}
              onTouchEnd={onTouchEnd}
            >
              <div
                className="absolute inset-0 grid gap-[2px] md:gap-0.5"
                style={{ 
  gridTemplateColumns: `repeat(${N}, 1fr)`, 
  gridTemplateRows: `repeat(${N}, 1fr)` 
}}

              >
                {Array.from({ length: N * N }).map((_, i) => {
                  const x = i % N;
                  const y = Math.floor(i / N);
                  const k = key(x, y);
                  const cellColor = (occupancy[y] || [])[x];
                  const isObstacle = obstacles.has(k);
                  const isNode = nodesByCell.get(k);
                  const isBridge = bridges.has(k);
                  const portal = portalMap.get(k);
                  const mix = mixNodes.get(k);
                  const bset = bridgeOcc[k];

                  const borderClass = isNode ? (COLOR_BORDER[isNode.color] || "") : "border-gray-200 dark:border-white/10";
                  const glowClass = isNode ? (COLOR_GLOW[isNode.color] || "") : "";

                  return (
                    <div
                      key={k}
                      className={[
                        "relative rounded-2xl border bg-white/80 dark:bg-slate-900/40",
                        "overflow-hidden transition-all duration-150",
                        borderClass
                      ].join(" ")}
                    >
                      {/* Base tile subtle gradient */}
                      <div className="absolute inset-0 bg-gradient-to-br from-white/80 to-slate-100/60 dark:from-slate-900/40 dark:to-slate-800/30"></div>

                      {/* Fill color (normal cell) */}
                      {cellColor && !isObstacle && !isBridge && (
                        <div className={`absolute inset-[4px] md:inset-[6px] rounded-xl opacity-95 shadow ${COLOR_FILL[cellColor] || ""}`}></div>

                      )}

                      {/* Bridge cell (side-by-side lanes) */}
                      {isBridge && (
                        <div className="absolute inset-[4px] md:inset-[6px] rounded-xl bg-slate-50 dark:bg-slate-800/70 border border-slate-200/70 dark:border-white/10">
                          <div className="absolute inset-1 flex gap-1 items-stretch justify-stretch">
                            {Array.from(bset || new Set()).slice(0, 2).map((c, idx) => (
                                <div key={idx} className={`w-1/2 rounded-lg opacity-95 shadow ${COLOR_FILL[c] || ""}`}></div>

                            ))}
                          </div>
                        </div>
                      )}

                      {/* Obstacle */}
                      {isObstacle && (
                        <div className="absolute inset-0 flex items-center justify-center">
                          <div className="w-2/3 h-2/3 rounded-xl bg-slate-700/80 dark:bg-slate-300/70"></div>
                        </div>
                      )}

                      {/* Portal & Mix badges */}
                      {portal && !isObstacle && (
                        <div className="absolute top-1.5 right-1.5 text-[10px] md:text-xs bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-200 px-1.5 py-0.5 rounded">⟲</div>
                      )}
                      {mix && !isObstacle && (
                        <div className="absolute bottom-1.5 right-1.5 text-[10px] md:text-xs bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200 px-1.5 py-0.5 rounded">+{mix.pigment}</div>
                      )}

                      {/* Node */}
                      {isNode && (
                        <div className="absolute inset-0 flex items-center justify-center">
                            <div
  className={`w-3.5 h-3.5 md:w-4 md:h-4 rounded-full ring-2 ring-white/90 dark:ring-black/40 shadow ${COLOR_FILL[isNode.color] || ""} ${glowClass}`}
></div>

                        </div>
                      )}

                      {/* Bridge mark */}
                      {isBridge && <div className="absolute top-1 left-1 text-[10px] md:text-xs text-gray-400">⛉</div>}
                    </div>
                  );
                })}
              </div>

              {/* Grid lines (toggle) */}
              {showGrid && (
                <svg
                  className="absolute inset-0 w-full h-full pointer-events-none"
                  viewBox={`0 0 ${N} ${N}`}

                  preserveAspectRatio="none"
                >
                  {Array.from({ length: N + 1 }).map((_, i) => (
                    <g key={i}>
                      <line x1={i} y1={0} x2={i} y2={N} stroke="#e5e7eb" strokeWidth={0.03} />
                      <line x1={0} y1={i} x2={N} y2={i} stroke="#e5e7eb" strokeWidth={0.03} />
                    </g>
                  ))}
                </svg>
              )}

              {/* Completed overlay */}
              {complete && (
                <div className="absolute inset-0 bg-black/30 backdrop-blur-[2px] flex items-center justify-center rounded-3xl">
                  <div className="pop-anim glass rounded-3xl p-6 md:p-8 text-center shadow-xl border border-white/50 dark:border-white/10">
                    <div className="text-2xl md:text-3xl font-extrabold">Level Cleared ✨</div>
                    <div className="mt-2 text-sm text-gray-700 dark:text-slate-300">Great job! Tất cả ô đã được phủ màu.</div>
                    <div className="mt-5 flex items-center justify-center gap-2">
                      <button onClick={resetLevel} className="px-4 py-2 rounded-xl bg-white hover:bg-white/90 shadow border text-sm">
                        Replay
                      </button>
                      <button onClick={nextLevel} className="px-4 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700 shadow text-sm">
                        Next Level →
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Controls row beneath board */}
            <div className="w-full max-w-5xl flex flex-wrap items-center justify-between gap-3">
              <div className="flex items-center gap-2">
                <button
                  onClick={() => (isComplete() ? nextLevel() : null)}
                  className={`px-4 py-2 rounded-xl shadow ${isComplete() ? "bg-emerald-600 text-white hover:bg-emerald-700" : "bg-gray-200 text-gray-500 dark:bg-white/10 dark:text-slate-400"}`}
                  title={isComplete() ? "Đi tới màn kế tiếp" : "Hãy hoàn thành để tiếp tục"}
                >
                  {isComplete() ? "Next Level →" : "Hoàn thành để tiếp tục"}
                </button>

                <button
                  onClick={() => setShowGrid(v => !v)}
                  className="px-3 py-2 rounded-xl bg-white/80 hover:bg-white shadow border text-sm"
                  title="Bật/tắt lưới"
                >
                  {showGrid ? "Hide Grid" : "Show Grid"}
                </button>
              </div>

              {/* Legend */}
              <div className="flex items-center flex-wrap gap-2 text-xs text-gray-600 dark:text-slate-300/80">
                <span className="px-2 py-1 rounded-lg bg-white/70 border">Bridge ⛉</span>
                <span className="px-2 py-1 rounded-lg bg-white/70 border">Portal ⟲</span>
                <span className="px-2 py-1 rounded-lg bg-white/70 border">Mix +pigment</span>
              </div>
            </div>

            {/* Tips */}
            <div className="w-full max-w-5xl grid md:grid-cols-3 gap-3 text-sm">
              <div className="glass rounded-2xl p-3 border shadow-sm">
                <div className="font-semibold mb-1">Cách chơi</div>
                <div>• Kéo từ một <span className="font-semibold">node màu</span> để bắt đầu.</div>
                <div>• Nối 2 node cùng màu để hoàn tất 1 đường.</div>
                <div>• Phủ kín bảng (trừ vật cản) để win.</div>
              </div>
              <div className="glass rounded-2xl p-3 border shadow-sm">
                <div className="font-semibold mb-1">Công cụ</div>
                <div>• <span className="font-semibold">Undo</span> để lùi 1 bước.</div>
                <div>• <span className="font-semibold">Hint</span> gợi ý 1 bước (BFS cơ bản).</div>
                <div>• <span className="font-semibold">Reset</span> để chơi lại.</div>
              </div>
              <div className="glass rounded-2xl p-3 border shadow-sm">
                <div className="font-semibold mb-1">Ô đặc biệt</div>
                <div>• <span className="font-semibold">Bridge</span> cho phép 2 màu đi chồng lane.</div>
                <div>• <span className="font-semibold">Portal</span> dịch chuyển tức thì.</div>
                <div>• <span className="font-semibold">Mix</span> trộn màu (R+B=P, R+Y=O, B+Y=G).</div>
              </div>
            </div>

            <footer className="py-2 text-xs text-gray-500 dark:text-slate-400">
              © {new Date().getFullYear()} Color Weaver – Prototype UI
            </footer>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<FlowPuzzle />);
    </script>
  </body>
</html>
