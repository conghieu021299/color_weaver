<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flow Puzzle – Color Weaver (UI)</title>

    <script>
      // Tailwind: chỉ bật dark mode khi <html class="dark">
      tailwind.config = { darkMode: 'class' };
    </script>
    <!-- Tailwind CDN (dev only) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Styles tách riêng -->
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body class="bg-animated text-black">
    <div id="root"></div>

    <!-- React 18 UMD -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel to compile JSX in-browser (dev only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- App (JSX) – import logic + levels như module -->
    <script type="text/babel" data-presets="react" data-type="module">
      import {
        key, isAdj, neighborsOf, mixAfter,
        solvePathForColor, orderColors, applySolutionPaths,
        computeProgress, isBoardComplete, solveAllColors,
      } from './logic.js';
      import LEVELS from './levels.js';

      const { useEffect, useMemo, useRef, useState } = React;

      // UI-only color classes (Tailwind)
      const COLOR_FILL = {
        red:"bg-red-500", blue:"bg-blue-500", yellow:"bg-yellow-400",
        green:"bg-green-500", orange:"bg-orange-500", purple:"bg-purple-500",
        teal:"bg-teal-500", pink:"bg-pink-500",
      };
      const COLOR_BORDER = {
        red:"border-red-400", blue:"border-blue-400", yellow:"border-yellow-300",
        green:"border-green-400", orange:"border-orange-400", purple:"border-purple-400",
        teal:"border-teal-400", pink:"border-pink-400",
      };
      const COLOR_GLOW = {
        red:"glow-red", blue:"glow-blue", yellow:"glow-yellow",
        green:"glow-green", orange:"glow-orange", purple:"glow-purple",
        teal:"glow-teal", pink:"glow-pink",
      };

      // Mix rule (game design) – UI truyền xuống logic khi cần
      const MIX_RULES = {
        "red+blue":"purple","blue+red":"purple",
        "red+yellow":"orange","yellow+red":"orange",
        "blue+yellow":"green","yellow+blue":"green",
      };

      function FlowPuzzle() {
        // Lấy level từ ?level=1..N
        const urlParams = new URLSearchParams(window.location.search);
        const levelParam = parseInt(urlParams.get('level') || '1', 10);
        const startLevelIndex = isNaN(levelParam) ? 0 : Math.min(LEVELS.length - 1, Math.max(0, levelParam - 1));
        const [levelIndex, setLevelIndex] = useState(startLevelIndex);

        const level = LEVELS[levelIndex];
        const N = level.gridSize;

        // Derived maps/sets từ level (UI giữ cấu trúc, logic chỉ nhận dữ liệu)
        const nodesByCell = useMemo(() => {
          const map = new Map();
          for (const n of level.nodes) map.set(key(n.x, n.y), { color: n.color });
          return map;
        }, [level]);

        const endpointsByColor = useMemo(() => {
          const by = {};
          for (const n of level.nodes) {
            by[n.color] ??= [];
            by[n.color].push({ x: n.x, y: n.y });
          }
          return by;
        }, [level]);

        const obstacles = useMemo(() => new Set((level.obstacles || []).map(o => key(o.x, o.y))), [level]);
        const bridges   = useMemo(() => new Set((level.bridges   || []).map(o => key(o.x, o.y))), [level]);
        const portalMap = useMemo(() => {
          const m = new Map();
          for (const p of (level.portals || [])) {
            m.set(key(p.a.x, p.a.y), { x: p.b.x, y: p.b.y });
            m.set(key(p.b.x, p.b.y), { x: p.a.x, y: p.a.y });
          }
          return m;
        }, [level]);
        const mixNodes  = useMemo(() => {
          const m = new Map();
          for (const mn of (level.mixNodes || [])) m.set(key(mn.x, mn.y), { pigment: mn.pigment });
          return m;
        }, [level]);

        // UI state
        const [occupancy, setOccupancy] = useState(
          Array.from({ length: N }, () => Array.from({ length: N }, () => null))
        );
        const [bridgeOcc, setBridgeOcc] = useState({});
        const [paths, setPaths] = useState({});
        const [active, setActive] = useState(null);
        const [showGrid, setShowGrid] = useState(true);
        const [history, setHistory] = useState([]);
        const boardRef = useRef(null);

        // Undo snapshot
        function takeSnapshot() {
          setHistory(h => [
            ...h,
            {
              occupancy: occupancy.map(r => r.slice()),
              bridgeOcc: Object.fromEntries(
                Object.entries(bridgeOcc).map(([k, v]) => [k, Array.from(v || [])])
              ),
              paths: Object.fromEntries(
                Object.entries(paths).map(([c, p]) => [c, p.map(pp => ({ ...pp }))])
              ),
              active: active ? { color: active.color, path: active.path.map(p => ({ ...p })) } : null,
            },
          ]);
        }
        function undo() {
          const prev = history[history.length - 1];
          if (!prev) return;
          setHistory(h => h.slice(0, -1));
          setOccupancy(prev.occupancy.map(r => r.slice()));
          setBridgeOcc(
            Object.fromEntries(Object.entries(prev.bridgeOcc).map(([k, arr]) => [k, new Set(arr)]))
          );
          setPaths(
            Object.fromEntries(Object.entries(prev.paths).map(([c, p]) => [c, p.map(pp => ({ ...pp }))]))
          );
          setActive(prev.active ? { color: prev.active.color, path: prev.active.path.map(p => ({ ...p })) } : null);
        }

        // Reset khi đổi level
        useEffect(() => {
          setPaths({});
          setActive(null);
          setOccupancy(Array.from({ length: N }, () => Array.from({ length: N }, () => null)));
          setBridgeOcc({});
          setHistory([]);
        }, [N, levelIndex]);

        // Map clientX/Y -> cell (UI)
        function pointToCell(clientX, clientY) {
          const el = boardRef.current;
          if (!el) return null;
          const rect = el.getBoundingClientRect();
          const size = Math.min(rect.width, rect.height);
          const cell = size / N;
          const offsetX = clientX - rect.left;
          const offsetY = clientY - rect.top;
          const startX = (rect.width - size) / 2;
          const startY = (rect.height - size) / 2;
          const xIn = offsetX - startX;
          const yIn = offsetY - startY;
          if (xIn < 0 || yIn < 0 || xIn >= size || yIn >= size) return null;
          const x = Math.floor(xIn / cell);
          const y = Math.floor(yIn / cell);
          if (x < 0 || y < 0 || x >= N || y >= N) return null;
          return { x, y };
        }

        function eraseColor(prev, color) {
          const clone = prev.map(row => row.slice());
          for (let y = 0; y < N; y++)
            for (let x = 0; x < N; x++)
              if (clone[y][x] === color) clone[y][x] = null;
          return clone;
        }

        function occupyBridgeCell(kc, color) {
          setBridgeOcc(prev => {
            const next = { ...prev };
            const s = new Set(Array.from((prev[kc] || [])));
            s.add(color);
            next[kc] = s;
            return next;
          });
        }

        // === Tương tác (UI gọi sang logic khi cần) ===
        function startDrawAt(cell) {
          const node = nodesByCell.get(key(cell.x, cell.y));
          if (!node) return; // phải bắt đầu ở node
          takeSnapshot();
          const color = node.color;

          setPaths(prev => {
            const np = { ...prev };
            if (np[color]) delete np[color];
            return np;
          });

          setOccupancy(prev => eraseColor(prev, color));

          setBridgeOcc(prev => {
            const copy = {};
            for (const [k, v] of Object.entries(prev)) {
              const nv = new Set(Array.from(v || []));
              nv.delete(color);
              copy[k] = nv;
            }
            return copy;
          });

          const kStart = key(cell.x, cell.y);
          if (bridges.has(kStart)) {
            occupyBridgeCell(kStart, color);
          } else {
            setOccupancy(prev => {
              const next = prev.map(r => r.slice());
              next[cell.y][cell.x] = color;
              return next;
            });
          }

          setActive({ color, path: [cell] });
        }

        function handleMoveTo(cell) {
          if (!active) return;
          const baseColor = active.color;
          const path = active.path;
          const last = path[path.length - 1];
          if (!isAdj(last, cell)) return;

          const k = key(cell.x, cell.y);
          if (obstacles.has(k)) return;

          // Backtrack một bước
          if (path.length >= 2) {
            const prevCell = path[path.length - 2];
            if (cell.x === prevCell.x && cell.y === prevCell.y) {
              takeSnapshot();
              const newPath = path.slice(0, -1);
              setActive({ color: baseColor, path: newPath });
              setOccupancy(prev => {
                const clone = prev.map(r => r.slice());
                clone[last.y][last.x] = null;
                return clone;
              });
              return;
            }
          }

          takeSnapshot();

          setOccupancy(prev => {
            let next = prev.map(r => r.slice());
            const occ = next[cell.y][cell.x];
            if (occ && occ !== baseColor && !bridges.has(k)) {
              next = eraseColor(next, occ);
              setPaths(p => {
                const np = { ...p };
                delete np[occ];
                return np;
              });
            }
            if (bridges.has(k)) occupyBridgeCell(k, baseColor);
            else next[cell.y][cell.x] = baseColor;
            return next;
          });

          let color = mixAfter(cell, baseColor, mixNodes, MIX_RULES);

          const newPath = [...path, cell];
          const endpoints = endpointsByColor[color] || endpointsByColor[baseColor];
          const reachedOther =
            endpoints &&
            endpoints.some(e => e.x === cell.x && e.y === cell.y) &&
            !(path.length === 1 && cell.x === path[0].x && cell.y === path[0].y);

          const portalDest = portalMap.get(k);
          let finalPath = newPath;
          if (portalDest) {
            finalPath = [...newPath, { x: portalDest.x, y: portalDest.y }];
            setOccupancy(prev => {
              const next = prev.map(r => r.slice());
              const kd = key(portalDest.x, portalDest.y);
              if (!bridges.has(kd)) next[portalDest.y][portalDest.x] = color;
              else occupyBridgeCell(kd, color);
              return next;
            });
          }

          if (reachedOther) {
            setPaths(prev => ({ ...prev, [color]: finalPath }));
            setActive(null);
          } else {
            setActive({ color, path: finalPath });
            setPaths(prev => ({ ...prev, [color]: finalPath }));
          }
        }

        function endDraw() {
          if (!active) return;
          const { color, path } = active;
          setPaths(prev => ({ ...prev, [color]: path }));
          setActive(null);
        }

        // Controls
        function resetLevel() {
          setPaths({});
          setActive(null);
          setOccupancy(Array.from({ length: N }, () => Array.from({ length: N }, () => null)));
          setBridgeOcc({});
          setHistory([]);
        }
        const nextLevel = () => setLevelIndex(i => Math.min(LEVELS.length - 1, i + 1));
        const prevLevel = () => setLevelIndex(i => Math.max(0, i - 1));

        // Hint / Auto-solve (gọi pure logic)
        function giveHint() {
          takeSnapshot();
          const result = solveAllColors({
            mode: 'all', N, occupancy, obstacles, bridges, portalMap,
            mixNodes, MIX_RULES, endpointsByColor, paths
          });
          if (!result) {
            // fallback: giải 1 cặp còn thiếu
            const one = solveAllColors({
              mode: 'pair', N, occupancy, obstacles, bridges, portalMap,
              mixNodes, MIX_RULES, endpointsByColor, paths
            });
            if (!one) return;
            setPaths(one.solution);
            setActive(null);
            setOccupancy(one.occ);
            setBridgeOcc(one.bOcc);
            return;
          }
          setPaths(result.solution);
          setActive(null);
          setOccupancy(result.occ);
          setBridgeOcc(result.bOcc);
        }

        // Events
        const complete = isBoardComplete(N, obstacles, occupancy, bridgeOcc, endpointsByColor, paths);
        const pct = computeProgress(N, obstacles, occupancy, bridgeOcc);

        const onPointerDown = e => { const c = pointToCell(e.clientX, e.clientY); if (c) startDrawAt(c); };
        const onPointerMove = e => { if (!active) return; const c = pointToCell(e.clientX, e.clientY); if (c) handleMoveTo(c); };
        const onPointerUp   = () => endDraw();

        const onTouchStart = e => { const t = e.touches[0]; if (!t) return; const c = pointToCell(t.clientX, t.clientY); if (c) startDrawAt(c); };
        const onTouchMove  = e => { const t = e.touches[0]; if (!t || !active) return; const c = pointToCell(t.clientX, t.clientY); if (c) handleMoveTo(c); };
        const onTouchEnd   = () => endDraw();

        // ---------- UI ----------
        return (
          <div className="min-h-screen w-full flex flex-col items-center gap-6 p-4 md:p-8" style={{position: 'relative', zIndex: 1}}>
            {/* Top bar */}
            <header className="w-full max-w-6xl glass rounded-3xl px-5 py-4 md:px-8 md:py-5 shadow-xl">
              <div className="flex flex-wrap items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 md:w-14 md:h-14 rounded-2xl bg-gradient-to-br from-violet-500 via-purple-500 to-fuchsia-500 shadow-xl ring-4 ring-white/30 floating flex items-center justify-center">
                    <span className="text-2xl">🎨</span>
                  </div>
                  <div>
                    <div className="text-2xl md:text-3xl font-black tracking-tight bg-gradient-to-r from-violet-600 to-fuchsia-600 bg-clip-text text-transparent">
                      Color Weaver
                    </div>
                    <div className="text-xs md:text-sm font-medium text-gray-700 dark:text-slate-200">
                      Connect colors • Fill the grid • Master the flow
                    </div>
                  </div>
                </div>

                <button 
                  onClick={() => (window.location.href = 'index.html')}
                  className="px-4 py-2.5 rounded-xl bg-white/90 hover:bg-white shadow-lg border border-white/50 text-sm font-semibold btn-hover-lift backdrop-blur-sm"
                >
                  ⟵ Home
                </button>
              </div>

              {/* Level navigation */}
              <div className="mt-5 flex items-center justify-center gap-3">
                <button 
                  onClick={prevLevel} 
                  disabled={levelIndex === 0}
                  className="px-4 py-2.5 rounded-xl bg-gradient-to-r from-violet-500 to-purple-500 text-white shadow-lg hover:shadow-xl disabled:opacity-50 disabled:cursor-not-allowed font-semibold btn-hover-lift"
                >
                  ◀ Prev
                </button>
                <div className="px-5 py-2.5 rounded-xl glass shadow-lg border text-sm md:text-base font-bold min-w-[200px] text-center">
                  {level.name}
                </div>
                <button 
                  onClick={nextLevel}
                  disabled={levelIndex === LEVELS.length - 1}
                  className="px-4 py-2.5 rounded-xl bg-gradient-to-r from-purple-500 to-fuchsia-500 text-white shadow-lg hover:shadow-xl disabled:opacity-50 disabled:cursor-not-allowed font-semibold btn-hover-lift"
                >
                  Next ▶
                </button>
              </div>

              {/* Action buttons */}
              <div className="mt-4 flex flex-wrap items-center justify-center gap-2">
                <button 
                  onClick={resetLevel} 
                  className="px-4 py-2 rounded-xl bg-white/90 hover:bg-white shadow-md border text-sm font-semibold btn-hover-lift"
                >
                  🔄 Reset
                </button>
                <button 
                  onClick={undo} 
                  disabled={history.length === 0}
                  className="px-4 py-2 rounded-xl bg-white/90 hover:bg-white shadow-md border text-sm font-semibold btn-hover-lift disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  ↶ Undo
                </button>
                <button 
                  onClick={giveHint} 
                  className="px-4 py-2 rounded-xl bg-gradient-to-r from-amber-500 to-orange-500 text-white shadow-lg hover:shadow-xl text-sm font-bold btn-hover-lift"
                >
                  💡 Hint
                </button>
                <button
                  onClick={() => setShowGrid(v => !v)}
                  className="px-4 py-2 rounded-xl bg-white/90 hover:bg-white shadow-md border text-sm font-semibold btn-hover-lift"
                >
                  {showGrid ? "🚫 Grid" : "⊞ Grid"}
                </button>
              </div>

              {/* Progress */}
              <div className="mt-5">
                <div className="flex items-center justify-between text-xs md:text-sm font-bold text-gray-700 dark:text-slate-200 mb-2">
                  <span className="flex items-center gap-2">
                    <span className="text-lg">📊</span>
                    Progress
                  </span>
                  <span className="px-3 py-1 rounded-lg bg-white/80 shadow-sm">
                    {pct}%
                  </span>
                </div>
                <div className="h-3 w-full rounded-full bg-white/40 dark:bg-slate-800/60 overflow-hidden shadow-inner relative">
                  <div 
                    className="h-full bg-gradient-to-r from-emerald-400 via-teal-500 to-cyan-500 transition-all duration-500 ease-out relative overflow-hidden" 
                    style={{width: pct + '%'}}
                  >
                    <div className="absolute inset-0 progress-shine"></div>
                  </div>
                </div>
              </div>
            </header>

            {/* Board */}
            <div
              ref={boardRef}
              className="relative w-full max-w-6xl aspect-square select-none touch-none glass rounded-3xl p-4 md:p-6 board-shadow"
              onPointerDown={onPointerDown}
              onPointerMove={onPointerMove}
              onPointerUp={onPointerUp}
              onPointerCancel={onPointerUp}
              onTouchStart={onTouchStart}
              onTouchMove={onTouchMove}
              onTouchEnd={onTouchEnd}
            >
              <div
                className="absolute inset-0 grid gap-[2px] md:gap-0.5"
                style={{ gridTemplateColumns: `repeat(${N}, 1fr)`, gridTemplateRows: `repeat(${N}, 1fr)` }}
              >
                {Array.from({ length: N * N }).map((_, i) => {
                  const x = i % N;
                  const y = Math.floor(i / N);
                  const k = key(x, y);
                  const cellColor = (occupancy[y] || [])[x];
                  const isObstacle = obstacles.has(k);
                  const isNode = nodesByCell.get(k);
                  const isBridge = bridges.has(k);
                  const portal = portalMap.get(k);
                  const mix = mixNodes.get(k);
                  const bset = bridgeOcc[k];

                  const borderClass = isNode ? (COLOR_BORDER[isNode.color] || "") : "border-gray-200 dark:border-white/10";
                  const glowClass = isNode ? (COLOR_GLOW[isNode.color] || "") : "";

                  return (
                    <div key={k}
                      className={[
                        "relative rounded-2xl border-2 bg-white/90 dark:bg-slate-900/50",
                        "overflow-hidden transition-all duration-200",
                        "hover:shadow-lg hover:scale-[1.02]",
                        borderClass
                      ].join(" ")}
                    >
                      <div className="absolute inset-0 bg-gradient-to-br from-white/90 via-slate-50/70 to-slate-100/80 dark:from-slate-900/50 dark:via-slate-800/40 dark:to-slate-700/30"></div>

                      {cellColor && !isObstacle && !isBridge && (
                        <div className={`absolute inset-[5px] md:inset-[7px] rounded-xl opacity-95 shadow-lg cell-animate ${COLOR_FILL[cellColor] || ""}`}></div>
                      )}

                      {isBridge && (
                        <div className="absolute inset-[4px] md:inset-[6px] rounded-xl bg-slate-50 dark:bg-slate-800/70 border border-slate-200/70 dark:border-white/10">
                          <div className="absolute inset-1 flex gap-1 items-stretch justify-stretch">
                            {Array.from(bset || new Set()).slice(0, 2).map((c, idx) => (
                              <div key={idx} className={`w-1/2 rounded-lg opacity-95 shadow ${COLOR_FILL[c] || ""}`}></div>
                            ))}
                          </div>
                        </div>
                      )}

                      {isObstacle && (
                        <div className="absolute inset-0 flex items-center justify-center">
                          <div className="w-2/3 h-2/3 rounded-xl bg-slate-700/80 dark:bg-slate-300/70"></div>
                        </div>
                      )}

                      {portal && !isObstacle && (
                        <div className="absolute top-1.5 right-1.5 text-[10px] md:text-xs bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-200 px-1.5 py-0.5 rounded">⟲</div>
                      )}
                      {mix && !isObstacle && (
                        <div className="absolute bottom-1.5 right-1.5 text-[10px] md:text-xs bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200 px-1.5 py-0.5 rounded">+{mix.pigment}</div>
                      )}

                      {isNode && (
                        <div className="absolute inset-0 flex items-center justify-center">
                          <div className={`w-4 h-4 md:w-5 md:h-5 rounded-full ring-[3px] ring-white/95 dark:ring-black/50 shadow-xl ${COLOR_FILL[isNode.color] || ""} ${glowClass}`}></div>
                        </div>
                      )}

                      {isBridge && <div className="absolute top-1 left-1 text-[10px] md:text-xs text-gray-400">⛉</div>}
                    </div>
                  );
                })}
              </div>

              {showGrid && (
                <svg className="absolute inset-0 w-full h-full pointer-events-none"
                     viewBox={`0 0 ${N} ${N}`} preserveAspectRatio="none">
                  {Array.from({ length: N + 1 }).map((_, i) => (
                    <g key={i}>
                      <line x1={i} y1={0} x2={i} y2={N} stroke="#e5e7eb" strokeWidth={0.03} />
                      <line x1={0} y1={i} x2={N} y2={i} stroke="#e5e7eb" strokeWidth={0.03} />
                    </g>
                  ))}
                </svg>
              )}

              {complete && (
                <div className="absolute inset-0 bg-gradient-to-br from-black/40 to-purple-900/30 backdrop-blur-md flex items-center justify-center rounded-3xl">
                  <div className="pop-anim glass rounded-3xl p-8 md:p-10 text-center shadow-2xl max-w-md">
                    <div className="text-5xl mb-4">🎉</div>
                    <div className="text-3xl md:text-4xl font-black bg-gradient-to-r from-emerald-400 via-teal-500 to-cyan-500 bg-clip-text text-transparent mb-3">
                      Level Cleared!
                    </div>
                    <div className="text-base md:text-lg text-gray-700 dark:text-slate-200 font-medium mb-6">
                      Perfect! Tất cả ô đã được phủ màu. 🌟
                    </div>
                    <div className="flex items-center justify-center gap-3">
                      <button 
                        onClick={resetLevel} 
                        className="px-6 py-3 rounded-xl bg-white/90 hover:bg-white shadow-lg border text-base font-bold btn-hover-lift"
                      >
                        🔄 Replay
                      </button>
                      <button 
                        onClick={nextLevel} 
                        className="px-6 py-3 rounded-xl bg-gradient-to-r from-emerald-500 to-teal-500 text-white hover:from-emerald-600 hover:to-teal-600 shadow-xl text-base font-bold btn-hover-lift"
                      >
                        Next Level →
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Special features info */}
            <div className="w-full max-w-6xl flex flex-wrap items-center justify-center gap-3">
              <div className="flex items-center gap-2 px-4 py-2 rounded-xl glass shadow-md border">
                <span className="text-lg">⛉</span>
                <span className="text-sm font-semibold text-gray-700 dark:text-slate-200">Bridge</span>
              </div>
              <div className="flex items-center gap-2 px-4 py-2 rounded-xl glass shadow-md border">
                <span className="text-lg">⟲</span>
                <span className="text-sm font-semibold text-gray-700 dark:text-slate-200">Portal</span>
              </div>
              <div className="flex items-center gap-2 px-4 py-2 rounded-xl glass shadow-md border">
                <span className="text-lg">➕</span>
                <span className="text-sm font-semibold text-gray-700 dark:text-slate-200">Color Mix</span>
              </div>
            </div>

            {/* Tips */}
            <div className="w-full max-w-6xl grid md:grid-cols-3 gap-4 text-sm">
              <div className="glass rounded-2xl p-5 border shadow-lg hover:shadow-xl transition-shadow">
                <div className="flex items-center gap-2 mb-3">
                  <span className="text-2xl">🎮</span>
                  <div className="font-bold text-lg text-gray-800 dark:text-white">Cách chơi</div>
                </div>
                <div className="space-y-2 text-gray-700 dark:text-slate-200">
                  <div className="flex items-start gap-2">
                    <span className="text-purple-500 font-bold">•</span>
                    <span>Kéo từ một <span className="font-bold text-purple-600 dark:text-purple-400">node màu</span> để bắt đầu</span>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-purple-500 font-bold">•</span>
                    <span>Nối 2 node cùng màu để hoàn thành đường</span>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-purple-500 font-bold">•</span>
                    <span>Phủ kín toàn bộ ô (trừ vật cản) để win</span>
                  </div>
                </div>
              </div>
              
              <div className="glass rounded-2xl p-5 border shadow-lg hover:shadow-xl transition-shadow">
                <div className="flex items-center gap-2 mb-3">
                  <span className="text-2xl">🛠️</span>
                  <div className="font-bold text-lg text-gray-800 dark:text-white">Công cụ</div>
                </div>
                <div className="space-y-2 text-gray-700 dark:text-slate-200">
                  <div className="flex items-start gap-2">
                    <span className="text-blue-500 font-bold">•</span>
                    <span><span className="font-bold text-blue-600 dark:text-blue-400">Undo</span> để quay lại bước trước</span>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-blue-500 font-bold">•</span>
                    <span><span className="font-bold text-amber-600 dark:text-amber-400">Hint</span> gợi ý hoặc giải tự động</span>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-blue-500 font-bold">•</span>
                    <span><span className="font-bold text-red-600 dark:text-red-400">Reset</span> để chơi lại từ đầu</span>
                  </div>
                </div>
              </div>
              
              <div className="glass rounded-2xl p-5 border shadow-lg hover:shadow-xl transition-shadow">
                <div className="flex items-center gap-2 mb-3">
                  <span className="text-2xl">✨</span>
                  <div className="font-bold text-lg text-gray-800 dark:text-white">Ô đặc biệt</div>
                </div>
                <div className="space-y-2 text-gray-700 dark:text-slate-200">
                  <div className="flex items-start gap-2">
                    <span className="text-emerald-500 font-bold">•</span>
                    <span><span className="font-bold text-emerald-600 dark:text-emerald-400">Bridge ⛉</span> cho 2 màu đi chéo</span>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-emerald-500 font-bold">•</span>
                    <span><span className="font-bold text-purple-600 dark:text-purple-400">Portal ⟲</span> dịch chuyển tức thì</span>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-emerald-500 font-bold">•</span>
                    <span><span className="font-bold text-amber-600 dark:text-amber-400">Mix +</span> trộn màu (R+B=P, R+Y=O, B+Y=G)</span>
                  </div>
                </div>
              </div>
            </div>

            <footer className="py-4 text-sm font-medium text-gray-600 dark:text-slate-300">
              <div className="flex items-center justify-center gap-2">
                <span>Made with</span>
                <span className="text-red-500 text-lg">❤️</span>
                <span>© {new Date().getFullYear()} Color Weaver</span>
              </div>
            </footer>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<FlowPuzzle />);
    </script>
  </body>
</html>
