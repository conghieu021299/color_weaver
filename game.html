<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Color Weaver - Flow Puzzle Game</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: auto;
  min-height: 100vh;
  overflow-x: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, Arial;
}

/* Animated gradient background */
@keyframes gradientShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

body {
  background: linear-gradient(
    135deg,
    #667eea 0%,
    #764ba2 25%,
    #f093fb 50%,
    #4facfe 75%,
    #667eea 100%
  );
  background-size: 400% 400%;
  animation: gradientShift 15s ease infinite;
  min-height: 100vh;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding: 20px;
  overflow-y: auto;
}

.container {
  width: 100%;
  max-width: 600px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin: 20px 0;
}

/* Glass card effect */
.card {
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(20px);
  border-radius: 24px;
  padding: 20px;
  box-shadow: 
    0 8px 32px rgba(0, 0, 0, 0.15),
    inset 0 1px 0 rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.5);
}

/* Header */
.header {
  text-align: center;
}

.title {
  font-size: 32px;
  font-weight: 900;
  background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}

.subtitle {
  font-size: 14px;
  color: #64748b;
  font-weight: 600;
}

/* Controls */
.controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 12px;
}

.level-nav {
  display: flex;
  align-items: center;
  gap: 12px;
}

.btn {
  padding: 10px 20px;
  border-radius: 12px;
  border: none;
  font-weight: 700;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

.btn:active:not(:disabled) {
  transform: translateY(0);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.btn-secondary {
  background: white;
  color: #334155;
  border: 2px solid #e2e8f0;
}

.btn-success {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
}

.level-display {
  padding: 10px 20px;
  background: white;
  border-radius: 12px;
  font-weight: 700;
  color: #334155;
  border: 2px solid #e2e8f0;
}

/* Progress bar */
.progress-container {
  margin-top: 12px;
}

.progress-label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  font-weight: 700;
  color: #64748b;
  margin-bottom: 8px;
}

.progress-bar {
  height: 10px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #10b981 0%, #14b8a6 100%);
  border-radius: 10px;
  transition: width 0.3s ease;
  position: relative;
  overflow: hidden;
}

@keyframes shine {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.4),
    transparent
  );
  animation: shine 2s infinite;
}

/* Game board */
.board-container {
  position: relative;
  width: 100%;
  aspect-ratio: 1;
  touch-action: none;
  user-select: none;
  background: rgba(30, 41, 59, 0.3);
  border-radius: 20px;
}

.board {
  position: absolute;
  inset: 0;
  display: grid;
  gap: 2px;
  padding: 8px;
}

.board-canvas {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 5;
}

.cell {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 8px;
  position: relative;
  transition: all 0.15s ease;
  border: 2px solid rgba(226, 232, 240, 0.3);
  z-index: 2;
}

.cell:hover {
  background: rgba(255, 255, 255, 0.7);
  transform: scale(1.02);
}

/* Cell colors - REMOVED, sáº½ dÃ¹ng SVG lines */

/* Node markers */
.node {
  position: absolute;
  inset: 25%;
  border-radius: 50%;
  box-shadow: 
    0 0 0 4px white,
    0 0 16px rgba(0, 0, 0, 0.3),
    0 0 24px currentColor;
  z-index: 15;
}

.node-red { background: #ef4444; color: #ef4444; }
.node-blue { background: #3b82f6; color: #3b82f6; }
.node-yellow { background: #fbbf24; color: #fbbf24; }
.node-green { background: #22c55e; color: #22c55e; }
.node-orange { background: #f97316; color: #f97316; }
.node-purple { background: #a855f7; color: #a855f7; }
.node-teal { background: #14b8a6; color: #14b8a6; }
.node-pink { background: #ec4899; color: #ec4899; }

/* Obstacle */
.obstacle {
  background: linear-gradient(135deg, #64748b 0%, #475569 100%);
  border-radius: 8px;
}

.obstacle::after {
  content: '';
  position: absolute;
  inset: 25%;
  background: #334155;
  border-radius: 4px;
}

/* Completion dialog */
.overlay {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 24px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 100;
}

.overlay.active {
  opacity: 1;
  pointer-events: all;
}

@keyframes popIn {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.dialog {
  background: white;
  border-radius: 20px;
  padding: 40px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
  animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  max-width: 90%;
  position: relative;
  z-index: 101;
}

.dialog-title {
  font-size: 36px;
  font-weight: 900;
  background: linear-gradient(135deg, #10b981 0%, #14b8a6 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 12px;
}

.dialog-text {
  font-size: 16px;
  color: #64748b;
  margin-bottom: 24px;
}

.dialog-buttons {
  display: flex;
  gap: 12px;
  justify-content: center;
}
</style>
</head>
<body>
<div class="container">
  <!-- Header -->
  <div class="card header">
    <div class="title">ðŸŽ¨ Color Weaver</div>
    <div class="subtitle">Connect the colors â€¢ Fill the grid â€¢ Master the flow</div>
  </div>

  <!-- Controls -->
  <div class="card">
    <div class="controls">
      <div class="level-nav">
        <button class="btn btn-primary" id="prevBtn" onclick="prevLevel()">â—€</button>
        <div class="level-display" id="levelDisplay">Level 1</div>
        <button class="btn btn-primary" id="nextBtn" onclick="nextLevel()">â–¶</button>
      </div>
      <div style="display: flex; gap: 8px;">
        <button class="btn btn-secondary" onclick="resetLevel()">ðŸ”„ Reset</button>
        <button class="btn btn-secondary" onclick="undo()">â†¶ Undo</button>
      </div>
    </div>
    
    <div class="progress-container">
      <div class="progress-label">
        <span>Progress</span>
        <span id="progressText">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
    </div>
  </div>

  <!-- Game Board -->
  <div class="card">
    <div class="board-container" id="boardContainer">
      <svg class="board-canvas" id="canvas" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
      <div class="board" id="board"></div>
      
      <!-- Completion overlay -->
      <div class="overlay" id="overlay">
        <div class="dialog">
          <div class="dialog-title">ðŸŽ‰ Level Cleared!</div>
          <div class="dialog-text">Perfect! All cells filled with colors.</div>
          <div class="dialog-buttons">
            <button class="btn btn-secondary" onclick="resetLevel()">ðŸ”„ Replay</button>
            <button class="btn btn-success" onclick="nextLevel()">Next Level â†’</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// Simple levels data (embedded)
const LEVELS = [
  {
    name: "Level 1",
    gridSize: 4,
    nodes: [
      { x: 0, y: 0, color: "red" }, { x: 3, y: 0, color: "red" },
      { x: 0, y: 3, color: "yellow" }, { x: 3, y: 3, color: "yellow" },
      { x: 0, y: 1, color: "blue" }, { x: 0, y: 2, color: "blue" },
      { x: 3, y: 1, color: "green" }, { x: 3, y: 2, color: "green" },
    ],
    obstacles: [{ x: 1, y: 1 }, { x: 1, y: 2 }, { x: 2, y: 1 }, { x: 2, y: 2 }],
  },
  {
    name: "Level 2",
    gridSize: 4,
    nodes: [
      { x: 0, y: 0, color: "red" }, { x: 3, y: 0, color: "red" },
      { x: 0, y: 3, color: "blue" }, { x: 3, y: 3, color: "blue" },
      { x: 0, y: 1, color: "yellow" }, { x: 1, y: 2, color: "yellow" },
      { x: 3, y: 1, color: "green" }, { x: 2, y: 2, color: "green" },
    ],
    obstacles: [{ x: 1, y: 1 }, { x: 2, y: 1 }],
  },
  {
    name: "Level 3",
    gridSize: 5,
    nodes: [
      { x: 0, y: 0, color: "red" }, { x: 4, y: 4, color: "red" },
      { x: 0, y: 4, color: "blue" }, { x: 4, y: 0, color: "blue" },
      { x: 1, y: 0, color: "yellow" }, { x: 3, y: 4, color: "yellow" },
    ],
    obstacles: [{ x: 2, y: 2 }],
  },
];

// Game state
let currentLevelIndex = 0;
let currentLevel = null;
let gridSize = 0;
let board = [];
let paths = {};
let drawing = null;
let history = [];

// Helper functions
const key = (x, y) => `${x},${y}`;
const isAdj = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1;

// Color mapping
const COLOR_HEX = {
  red: '#ef4444',
  blue: '#3b82f6',
  yellow: '#fbbf24',
  green: '#22c55e',
  orange: '#f97316',
  purple: '#a855f7',
  teal: '#14b8a6',
  pink: '#ec4899'
};

// Initialize game
function init() {
  loadLevel(currentLevelIndex);
}

function loadLevel(index) {
  currentLevelIndex = Math.max(0, Math.min(LEVELS.length - 1, index));
  currentLevel = LEVELS[currentLevelIndex];
  gridSize = currentLevel.gridSize;
  
  // Reset state
  board = Array.from({ length: gridSize }, () => 
    Array.from({ length: gridSize }, () => null)
  );
  paths = {};
  drawing = null;
  history = [];
  
  // Update UI
  updateLevelDisplay();
  renderBoard();
  updateProgress();
  hideOverlay();
}

function updateLevelDisplay() {
  document.getElementById('levelDisplay').textContent = currentLevel.name;
  document.getElementById('prevBtn').disabled = currentLevelIndex === 0;
  document.getElementById('nextBtn').disabled = currentLevelIndex === LEVELS.length - 1;
}

function renderBoard() {
  const boardEl = document.getElementById('board');
  const canvasEl = document.getElementById('canvas');
  
  boardEl.innerHTML = '';
  canvasEl.innerHTML = '';
  
  boardEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
  boardEl.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
  
  // Update SVG viewBox to match grid
  const viewSize = gridSize * 10;
  canvasEl.setAttribute('viewBox', `0 0 ${viewSize} ${viewSize}`);
  
  // Create cells
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      
      // Check if obstacle
      const isObstacle = currentLevel.obstacles?.some(o => o.x === x && o.y === y);
      if (isObstacle) {
        cell.classList.add('obstacle');
      }
      
      // Check if node
      const node = currentLevel.nodes.find(n => n.x === x && n.y === y);
      if (node) {
        const nodeMarker = document.createElement('div');
        nodeMarker.className = `node node-${node.color}`;
        cell.appendChild(nodeMarker);
      }
      
      boardEl.appendChild(cell);
    }
  }
  
  // Draw paths as SVG lines
  drawPaths();
}

function drawPaths() {
  const canvasEl = document.getElementById('canvas');
  canvasEl.innerHTML = '';
  
  // Draw completed paths
  for (const [color, path] of Object.entries(paths)) {
    if (path.length < 2) continue;
    drawPath(canvasEl, path, color);
  }
  
  // Draw active drawing path
  if (drawing && drawing.path.length > 0) {
    drawPath(canvasEl, drawing.path, drawing.color);
  }
}

function drawPath(svgEl, path, color) {
  const colorHex = COLOR_HEX[color] || '#999';
  const cellSize = 10; // ViewBox unit per cell
  
  for (let i = 0; i < path.length - 1; i++) {
    const from = path[i];
    const to = path[i + 1];
    
    // Calculate center positions
    const x1 = from.x * cellSize + cellSize / 2;
    const y1 = from.y * cellSize + cellSize / 2;
    const x2 = to.x * cellSize + cellSize / 2;
    const y2 = to.y * cellSize + cellSize / 2;
    
    // Create line element
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', colorHex);
    line.setAttribute('stroke-width', '2.5');
    line.setAttribute('stroke-linecap', 'round');
    line.setAttribute('opacity', '0.95');
    line.style.filter = `drop-shadow(0 0 8px ${colorHex}) drop-shadow(0 0 4px ${colorHex})`;
    
    svgEl.appendChild(line);
  }
}

// Drawing logic
const boardContainer = document.getElementById('boardContainer');

function getCellFromEvent(e) {
  const rect = boardContainer.getBoundingClientRect();
  const x = e.clientX || (e.touches && e.touches[0]?.clientX);
  const y = e.clientY || (e.touches && e.touches[0]?.clientY);
  
  if (!x || !y) return null;
  
  const relX = x - rect.left;
  const relY = y - rect.top;
  const cellSize = rect.width / gridSize;
  
  const col = Math.floor(relX / cellSize);
  const row = Math.floor(relY / cellSize);
  
  if (col < 0 || col >= gridSize || row < 0 || row >= gridSize) return null;
  
  return { x: col, y: row };
}

function startDrawing(cell) {
  const node = currentLevel.nodes.find(n => n.x === cell.x && n.y === cell.y);
  if (!node) return;
  
  saveHistory();
  
  const color = node.color;
  drawing = { color, path: [cell] };
  
  // Clear existing path of this color
  if (paths[color]) {
    paths[color].forEach(c => {
      board[c.y][c.x] = null;
    });
    delete paths[color];
  }
  
  board[cell.y][cell.x] = color;
  renderBoard();
  drawPaths();
}

function continueDraw(cell) {
  if (!drawing) return;
  
  const last = drawing.path[drawing.path.length - 1];
  if (!isAdj(last, cell)) return;
  
  // Check if obstacle
  const isObstacle = currentLevel.obstacles?.some(o => o.x === cell.x && o.y === cell.y);
  if (isObstacle) return;
  
  // Backtrack
  if (drawing.path.length >= 2) {
    const prev = drawing.path[drawing.path.length - 2];
    if (cell.x === prev.x && cell.y === prev.y) {
      const removed = drawing.path.pop();
      board[removed.y][removed.x] = null;
      drawPaths();
      return;
    }
  }
  
  // Clear cell if occupied by different color
  const existing = board[cell.y][cell.x];
  if (existing && existing !== drawing.color) {
    if (paths[existing]) {
      paths[existing].forEach(c => {
        board[c.y][c.x] = null;
      });
      delete paths[existing];
    }
  }
  
  board[cell.y][cell.x] = drawing.color;
  drawing.path.push(cell);
  
  // Check if reached other endpoint
  const endpoints = currentLevel.nodes.filter(n => n.color === drawing.color);
  const reachedEnd = endpoints.some(e => 
    e.x === cell.x && e.y === cell.y && 
    !(drawing.path.length === 1 && e.x === drawing.path[0].x && e.y === drawing.path[0].y)
  );
  
  if (reachedEnd) {
    paths[drawing.color] = [...drawing.path];
    drawing = null;
  }
  
  drawPaths();
  updateProgress();
  checkCompletion();
}

function stopDrawing() {
  if (drawing) {
    paths[drawing.color] = [...drawing.path];
    drawing = null;
  }
}

// Event listeners
boardContainer.addEventListener('mousedown', e => {
  const cell = getCellFromEvent(e);
  if (cell) startDrawing(cell);
});

boardContainer.addEventListener('mousemove', e => {
  if (!drawing) return;
  const cell = getCellFromEvent(e);
  if (cell) continueDraw(cell);
});

boardContainer.addEventListener('mouseup', () => stopDrawing());
boardContainer.addEventListener('mouseleave', () => stopDrawing());

// Touch support
boardContainer.addEventListener('touchstart', e => {
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (cell) startDrawing(cell);
});

boardContainer.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!drawing) return;
  const cell = getCellFromEvent(e);
  if (cell) continueDraw(cell);
});

boardContainer.addEventListener('touchend', e => {
  e.preventDefault();
  stopDrawing();
});

// Progress & completion
function updateProgress() {
  let filled = 0;
  let fillable = 0;
  
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const isObstacle = currentLevel.obstacles?.some(o => o.x === x && o.y === y);
      if (!isObstacle) {
        fillable++;
        if (board[y][x]) filled++;
      }
    }
  }
  
  const percent = fillable > 0 ? Math.round((filled / fillable) * 100) : 0;
  document.getElementById('progressText').textContent = percent + '%';
  document.getElementById('progressFill').style.width = percent + '%';
}

function checkCompletion() {
  // Check all colors connected
  for (const node of currentLevel.nodes) {
    const path = paths[node.color];
    if (!path || path.length < 2) return;
    
    const endpoints = currentLevel.nodes.filter(n => n.color === node.color);
    const connected = endpoints.every(e => 
      path.some(c => c.x === e.x && c.y === e.y)
    );
    
    if (!connected) return;
  }
  
  // Check all cells filled
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const isObstacle = currentLevel.obstacles?.some(o => o.x === x && o.y === y);
      if (!isObstacle && !board[y][x]) return;
    }
  }
  
  // Level complete!
  setTimeout(() => showOverlay(), 600);
}

function showOverlay() {
  document.getElementById('overlay').classList.add('active');
}

function hideOverlay() {
  document.getElementById('overlay').classList.remove('active');
}

// Controls
function nextLevel() {
  loadLevel(currentLevelIndex + 1);
}

function prevLevel() {
  loadLevel(currentLevelIndex - 1);
}

function resetLevel() {
  loadLevel(currentLevelIndex);
}

function saveHistory() {
  history.push({
    board: board.map(row => [...row]),
    paths: JSON.parse(JSON.stringify(paths))
  });
}

function undo() {
  if (history.length === 0) return;
  const prev = history.pop();
  board = prev.board;
  paths = prev.paths;
  drawing = null;
  renderBoard();
  drawPaths();
  updateProgress();
  hideOverlay();
}

// Start game
init();
</script>
</body>
</html>
